// Generated by Haxe 4.3.6
using global::Loreline.Internal.Root;

#pragma warning disable 109, 114, 219, 429, 168, 162, IL2026, IL2070, IL2072, IL2060, CS0108
namespace Loreline.Internal.Lang {
	public sealed class FieldHashConflict {
		
		public FieldHashConflict(int hash, string name, object @value, global::Loreline.Internal.Lang.FieldHashConflict next) {
			this.hash = hash;
			this.name = name;
			this.@value = @value;
			this.next = next;
		}
		
		
		public readonly int hash;
		
		public readonly string name;
		
		public object @value;
		
		public global::Loreline.Internal.Lang.FieldHashConflict next;
		
	}
}



#pragma warning disable 109, 114, 219, 429, 168, 162, IL2026, IL2070, IL2072, IL2060, CS0108
namespace Loreline.Internal.Lang {
	public sealed class FieldLookup {
		
		#pragma warning disable 628
		static FieldLookup() {
			global::Loreline.Internal.Lang.FieldLookup.length = ( global::Loreline.Internal.Lang.FieldLookup.fieldIds as global::System.Array ).Length;
		}
		
		
		public FieldLookup() {
		}
		
		
		protected static int[] fieldIds = new int[]{98, 101, 105, 109, 110, 114, 116, 22175, 23515, 24414, 24865, 4745537, 4846113, 4899635, 5046829, 5144726, 5343647, 5393365, 5395604, 5442204, 5442212, 5443986, 5544103, 5545010, 5545011, 5594513, 5594516, 5691745, 5741474, 5744817, 5841808, 9342585, 10916214, 28585706, 33649080, 33813649, 40034999, 42740551, 43737796, 47121374, 50254234, 52644165, 52892584, 55510161, 57219237, 57476627, 60029898, 62868984, 67856200, 67859554, 67859985, 68474919, 69051697, 71871848, 75232702, 75659674, 76061764, 78945784, 86284558, 87367608, 88678082, 91158421, 104493173, 109002835, 110099609, 110661850, 116192081, 116222917, 126419883, 128133950, 142151465, 142301684, 142895533, 157364934, 159640949, 170467784, 176082838, 178157919, 179047623, 184980900, 191553866, 191923584, 194144585, 195296495, 198842449, 199209814, 208459108, 209784577, 213039886, 213667897, 214869720, 221637784, 222029606, 225290809, 230682591, 238439747, 241500744, 244830897, 245971505, 246802744, 247969072, 249292073, 254255529, 265499831, 267192808, 273776389, 276573010, 278141802, 282239261, 282360088, 283690212, 292212294, 300357466, 302979532, 304404583, 306633900, 312752480, 324379125, 328878574, 331598489, 334695532, 337357167, 338395897, 341612509, 343868310, 359333139, 379699091, 385919945, 391139962, 397157895, 404153790, 407283053, 409826492, 410503296, 416145912, 419142827, 420199582, 420719055, 427265337, 429185260, 430862998, 437335495, 442647117, 444528186, 444663929, 451001976, 452356799, 452737314, 456957216, 461333821, 465315293, 473644160, 476102071, 477756888, 480756972, 492343061, 499027028, 500757153, 501039929, 504484589, 507663209, 508769650, 509207173, 520590566, 523507340, 528773354, 536864739, 537630174, 539737937, 543952711, 551767278, 555164043, 557215501, 572311959, 575935913, 591389657, 596483356, 598785079, 611419590, 613631498, 616774523, 618537130, 619027138, 630156697, 634543899, 637231206, 637940642, 648348836, 652994848, 661986841, 675998584, 678409610, 678777877, 679160171, 682095612, 687834278, 691028628, 701410669, 710162324, 710568689, 712301447, 718902759, 726215216, 726771330, 727184891, 738166156, 746281503, 746841097, 777465723, 782176664, 784433846, 792687011, 799206811, 803207803, 810640957, 810689960, 811551491, 811715804, 813247143, 825712952, 826550065, 832143272, 834174833, 838333445, 838796847, 845238484, 862380962, 863972113, 864408234, 869186480, 873998019, 874197400, 878103594, 878250472, 893479760, 897989649, 903219737, 903448271, 910198946, 914499717, 922671056, 928325564, 929195681, 932059829, 932127235, 933032312, 934751238, 934774029, 938146215, 946786476, 947177898, 953824755, 965613058, 965979401, 977714714, 982974890, 986361412, 995006396, 996728671, 997235974, 1007334196, 1007673663, 1015556155, 1016581564, 1025878820, 1029017651, 1029017888, 1040745046, 1041537810, 1042138122, 1043207553, 1043998965, 1047637208, 1049971873, 1050036222, 1054351781, 1054637901, 1058653591, 1059250339, 1061701563, 1067353468, 1071652316, 1071994523, 1081380189, 1090165044, 1091821942, 1092319906, 1095840978, 1100957193, 1100981319, 1102715038, 1103060694, 1103359965, 1103409453, 1103412149, 1104272297, 1113806382, 1122225097, 1124892161, 1126038837, 1128621150, 1136978756, 1145554120, 1148579289, 1149518628, 1150186626, 1151280105, 1152129377, 1153194234, 1158313662, 1158359328, 1158559586, 1159150621, 1167534896, 1169594568, 1173624273, 1177754921, 1181037546, 1183534806, 1184311830, 1191633396, 1191829844, 1192939994, 1193153968, 1194336987, 1197201529, 1197493771, 1199976273, 1202718727, 1202720510, 1202919412, 1204816148, 1213612268, 1213811397, 1213952397, 1220597281, 1224700491, 1224901875, 1225098545, 1225394690, 1226371975, 1229275964, 1231639053, 1233995395, 1234125620, 1244803897, 1246880755, 1246881189, 1247076763, 1247473716, 1247475490, 1247875546, 1254379272, 1257164128, 1258363366, 1260990571, 1263696114, 1267426050, 1269755426, 1273207865, 1274863514, 1275479599, 1275710009, 1275922997, 1280150333, 1280345457, 1280549057, 1280845662, 1281342043, 1281790228, 1281817653, 1282943179, 1285965006, 1291236569, 1291439277, 1292432058, 1301394908, 1304366305, 1310095788, 1311373170, 1313416818, 1317134924, 1319769887, 1324265963, 1328479863, 1334311054, 1337394146, 1348037855, 1352786672, 1353735125, 1354931324, 1361606707, 1365207622, 1365803947, 1367480579, 1368088229, 1375221624, 1386303363, 1389332563, 1395555037, 1411440466, 1420518939, 1420772493, 1422425789, 1431819701, 1436822557, 1439586474, 1441575351, 1443990783, 1449108079, 1450762973, 1460447810, 1462366467, 1467341116, 1476741521, 1481290936, 1483922940, 1487047055, 1490987234, 1499183351, 1501684331, 1505719464, 1512997393, 1514498371, 1514749454, 1516674499, 1522079560, 1525029630, 1525029631, 1527816632, 1529001214, 1532710347, 1537812987, 1539193051, 1539229357, 1545159324, 1545531726, 1547539107, 1547800410, 1549008848, 1557350120, 1557555762, 1565955023, 1570649060, 1575472496, 1576149820, 1589672013, 1593465353, 1595357512, 1598927078, 1610494814, 1614780307, 1615048282, 1615461975, 1618251324, 1619604762, 1619608547, 1620824029, 1621420777, 1623148745, 1630079509, 1637015115, 1637368501, 1639293562, 1648581351, 1650123424, 1660787710, 1664304497, 1670156296, 1673559700, 1673827389, 1688695337, 1694639191, 1702898679, 1704221808, 1705629508, 1723044296, 1724402127, 1726092565, 1729900821, 1734349548, 1735572730, 1736653984, 1737727934, 1740350493, 1740896811, 1745227786, 1751273038, 1756866521, 1764687976, 1765034691, 1765771592, 1768164316, 1768617329, 1771682515, 1773615436, 1777527093, 1783401820, 1789945678, 1793290388, 1801050517, 1803772521, 1815309403, 1818918322, 1820783079, 1821243014, 1824207184, 1825849507, 1830181323, 1830310359, 1833184846, 1835969119, 1836776262, 1836975401, 1839230540, 1843688755, 1848869397, 1849631693, 1849909130, 1854502514, 1855995620, 1858831770, 1863059586, 1863180102, 1865784786, 1869704293, 1880302217, 1887596712, 1891834246, 1892331232, 1900414603, 1900716655, 1909323791, 1911284859, 1913514584, 1915412854, 1916009602, 1918417798, 1920220453, 1920411396, 1929358819, 1932118984, 1933704121, 1937159360, 1940399131, 1947814499, 1958679431, 1959696604, 1969618304, 1969968352, 1975882124, 1978344266, 1981972957, 1982509203, 1984794979, 1985120491, 2022294396, 2025055113, 2027516308, 2032525045, 2044994131, 2045446969, 2048392659, 2049891659, 2057163599, 2063384608, 2082581827, 2082663554, 2083776923, 2085560561, 2090419204, 2096228120, 2105131003, 2107800143, 2113708439, 2115507486, 2116027125, 2125505269, 2127021138, 2134890874, 2139336184, 2140389027};
		
		protected static string[] fields = new string[]{"b", "e", "i", "m", "n", "r", "t", "cb", "id", "mk", "op", "__a", "add", "buf", "elt", "get", "key", "len", "low", "map", "max", "min", "old", "ops", "opt", "pop", "pos", "ret", "set", "str", "uid", "fields", "startLine", "resumeIf", "elseStyle", "resumeNodeBody", "variables", "flags", "flush", "readPos", "opRightAssoc", "match", "maybe", "resolveArrayAccess", "compare", "getEnumConstructs", "resolveBeatFromCall", "parseImport", "stack", "start", "state", "wrapInRootBeat", "style", "parseFunctionArgs", "ensure", "readAccess", "remove", "__previousException", "topLevelBeats", "filter", "parseMetadata", "isComment", "parseFunctionDecl", "finish", "parseLogicalOr", "makeBinop", "target", "exprReturn", "parseExpression", "isBeatCall", "classString", "resize", "resume", "leading", "serializeBeatReference", "makeLooseOrStrictAfterBracket", "currentNodeId", "thenBranch", "readString", "access", "getAncestors", "parseStructure", "parseModuleDecl", "followsCallableOrIndexable", "evalTransition", "parseStringTag", "parseString", "output", "isAfterLBracket", "topLevelCharacters", "lastTokenEnd", "__nativeException", "setLoop", "isPrivate", "evalStateDecl", "restoreValue", "readMultiLineComment", "compareArg", "parseStatementBlock", "findNodes", "assignOp", "handleChoice", "serializeCharacter", "makePosition", "findModifiedStateFields", "followsWithIf", "parseObject", "getNodeById", "findBeatByNameFromNode", "allowMetadata", "nodeStates", "getVisibleCharacters", "tokens", "methodName", "restoreFields", "preprocess", "get_native", "readLineBreak", "iterator", "evalIf", "indent", "literal", "token", "wrapNext", "dateUTC", "lastIndexOf", "findReadCharacterFields", "literalType", "getIdent", "isWhitespace", "replacer", "hasNext", "evalBeatDecl", "findModifiedCharacterFields", "followsOnlyWhitespacesOrCommentsInLine", "pendingComments", "flushing", "evaluateFunctionCall", "content", "evalAssignOp", "inString", "message", "parseEquality", "countIndentation", "serializeFields", "keysLoop", "readNumber", "reverse", "parseStringInterpolation", "valueToString", "findBeatFromAccess", "parseCharacterDecl", "parseFullExpr", "beatByName", "nOccupied", "getFirstParentOfType", "endsWithChar", "initializeState", "insert", "multiline", "serializeNodeReference", "initializeTopLevelState", "prevNonWhitespaceOrComment", "length", "hashCoords", "isExtern", "writeAccess", "get_message", "evaluateExpression", "loopRun", "isAtLineBreak", "duplicate", "elseLeading", "native", "parseArrayLiteral", "findBeatCharacters", "balance", "previous", "createOriginalFields", "evaluateString", "findReadStateFields", "tokenString", "isAfterLabel", "array", "processInput", "tokenComment", "_random", "getAllTags", "invalidNumber", "attachComments", "preprocValue", "resolveAssignmentTarget", "initialSeed", "characterPos", "opChars", "requiresNewLine", "constString", "invalidChar", "serializeScope", "isInsideBrackets", "parseField", "isWhiteSpace", "trailingComments", "findStateField", "tokenize", "restoreBeatToResume", "contains", "namePos", "_exists", "expression", "pretty", "implement", "parseChoiceStatement", "restoreCharacter", "beats", "evalPreproCond", "resumeChoiceOption", "skipWhitespace", "parentNodes", "resumeErrors", "allowJSON", "parseTransition", "value", "readIdentifierTokenInInterpolation", "increment", "evalDialogue", "expectIdentifier", "__nativeStack", "serializeCharacters", "processComment", "endsOrFollowsWithChar", "restoreCharacters", "fieldsString", "parseBlockStart", "synchronize", "serializeState", "isAlphaNumeric", "evaluateArrayLiteral", "compareArgs", "nextNonWhitespaceOrComment", "cachedIndex", "processLineBreak", "parseLogicalAnd", "elseTrailing", "random", "indentLevel", "transitionToBeat", "skipNulls", "allowTabs", "toString", "originalFields", "prevWithType", "evaluateCondition", "elseTrailingComments", "leadingComments", "doWhileLoop", "parseDialogueStatement", "hashes", "readIdentifier", "nextToken", "findOutboundBeats", "parseModule", "elseBranch", "readFieldAccessInterpolation", "get_currentPos", "parse", "parts", "inTry", "index", "input", "_values", "childNodes", "startColumn", "returnValue", "isOriginalScriptExpression", "opPriority", "indentSize", "_get", "_set", "makeStringPartPosition", "splice", "exists", "currentScope", "args", "comments", "beat", "body", "isMap", "tokenized", "mapCompr", "call", "char", "cnew", "code", "copy", "character", "date", "operand", "each", "expr", "isAtEnd", "func", "makeUnop", "expect", "get_currentScope", "getParentNode", "isAssignStart", "elseLeadingComments", "declared", "findCharacterByNameFromNode", "head", "high", "evalChoice", "allowTypes", "check", "unexpected", "__skipStack", "join", "column", "followsOnlyLabelOrCommentsInLine", "keys", "kind", "extend", "resolveAccess", "currentPos", "inControlWithoutParens", "script", "checkIdentifier", "left", "lens", "line", "concat", "mask", "meta", "clear", "getVisibleBeats", "name", "next", "nind", "node", "getCharacterField", "indentStack", "forLoop", "tryReadUnquotedString", "parseIdentifierExpression", "evalBeatRun", "part", "path", "peek", "pmax", "pmin", "push", "parseExpr", "keyValueIterator", "origin", "parseStringLiteral", "findCharacterFromDialogue", "initOps", "root", "current", "parseLambda", "assign", "withOffset", "execute", "save", "seed", "size", "sort", "sync", "thenStyle", "makeStrictIfFollowingCallable", "quicksort", "currentPosOffset", "tags", "text", "type", "nextScopeId", "getErrors", "topLevelFunctions", "evalChoiceOption", "vals", "preprocesorValues", "parseIfStatement", "getMapValue", "findBeatByPathFromNode", "readFunction", "values", "write", "spliceVoid", "parseNode", "parseUnary", "getCharacter", "nextLineIndentOffset", "errors", "isBlock", "parseCallArguments", "parsePath", "idents", "parseBeatDecl", "cachedKey", "findReferencesToBeat", "handleFinish", "parseType", "checkBlockStart", "createEnumIndex", "createEnum", "characters", "quotes", "parsePreproCond", "isIdentifierStart", "parseRec", "__ownStack", "depth", "prevIdentifier", "temporary", "rootBeat", "makeIterator", "parseTextStatement", "topLevelState", "setMapValue", "parseFunction", "locals", "posInfos", "getClosestNodeAtOrBeforePosition", "matchIdentifier", "isTransitionStart", "lineBreakAfterToken", "_keys1", "_keys2", "skipQuotedString", "makePositionRelativeTo", "concatNative", "nBuckets", "getTypeName", "keyIterator", "hasNonSpecialChar", "makeMap", "className", "nextBlock", "nextNodeId", "resetVariables", "makeAccess", "parsePrimary", "restoreBeat", "_skipWhitespaceAndComments", "quote", "partType", "evalAssignment", "countTags", "indentTokens", "options", "offset", "evalCall", "initializeTopLevelFunction", "initializeTopLevelFunctions", "restoreStack", "restoreState", "__unsafe_get", "__unsafe_set", "indexOf", "lineOutput", "nextNonLineBreakOrComment", "whileLoop", "lookup", "fileName", "parseConditionExpression", "followsWithChar", "serializeValue", "parseObjectField", "extendedTo", "parseObjectLiteral", "parseMultiplicative", "evaluateObjectLiteral", "isIdentifierExpressionStart", "restoreNode", "toDynamic", "between", "reset", "isColon", "readLineComment", "resolve", "inComment", "processString", "evalNode", "parentBlockType", "makeToken", "endsWithControlKeyword", "getVisibleStateFields", "parseParams", "parseStateDecl", "targetPos", "resumeBeatRun", "right", "allEnums", "isStrict", "readChar", "initializeTopLevelBeat", "parseComparison", "restore", "getNodeAtPosition", "strictExprs", "evalText", "ensureToken", "traverse", "addError", "isIdentifierPart", "initialize", "unwrap", "binops", "customParams", "findBeatFromTransition", "parseAdditive", "params", "parens", "posOffsets", "syncCallbacks", "parseMetaArgs", "identChars", "initializeTopLevelCharacter", "attachElseComments", "serializeNodeStates", "isCallStart", "advance", "performOperation", "restoreNodeStates", "setVar", "parseChoiceOption", "doParse", "_height", "isExpressionStart", "compareAttachments", "process", "initParser", "isIfStart", "isLabelStart", "__get", "__set", "parseExprList", "finishTrigger", "parseExpressionStatement", "_remove", "error", "checkString", "__hx_deleteField", "parseExprNext", "nodesById", "isKnownNodeStart", "trailing", "evalNodeBody", "handleDialogue", "getNodesOfType", "readComplexInterpolation", "lineNumber", "rethrow", "isDigit", "resumeCall", "upperBound", "unshift", "scope", "closing", "isNumber", "skipTokens", "_keys", "brackets", "preprocStack", "parseTypeNext", "toJson", "shift", "condition", "followsAssignStart", "fcall", "version", "inBeat", "resumeNode", "addChar", "beatToResume", "lastLineBreak", "nextTokenWithPosition", "slice", "inStateOrCharacter", "inControl", "isAfterComma"};
		
		protected static int length;
		
		public static void addFields(int[] nids, string[] nfields) {
			unchecked {
				int[] cids = global::Loreline.Internal.Lang.FieldLookup.fieldIds;
				string[] cfields = global::Loreline.Internal.Lang.FieldLookup.fields;
				int nlen = ( nids as global::System.Array ).Length;
				int clen = global::Loreline.Internal.Lang.FieldLookup.length;
				if (( ( nfields as global::System.Array ).Length != nlen )) {
					throw ((global::System.Exception) (global::Loreline.Internal.Exception.thrown(global::Loreline.Internal.Lang.Runtime.concat(global::Loreline.Internal.Lang.Runtime.concat(global::Loreline.Internal.Lang.Runtime.concat("Different fields length: ", global::Loreline.Internal.Lang.Runtime.toString(nlen)), " and "), global::Loreline.Internal.Lang.Runtime.toString(( nfields as global::System.Array ).Length)))) );
				}
				
				bool needsChange = false;
				{
					int[] _g_arr = nids;
					uint _g_idx = ((uint) (0) );
					while (( _g_idx < ( _g_arr as global::System.Array ).Length )) {
						_g_idx += ((uint) (1) );
						int i = _g_arr[((int) (((uint) (( _g_idx - 1 )) )) )];
						if (( global::Loreline.Internal.Lang.FieldLookup.findHash(i, cids, clen) < 0 )) {
							needsChange = true;
							break;
						}
						
					}
					
				}
				
				if (needsChange) {
					lock(typeof(global::Loreline.Internal.Lang.FieldLookup)){
						int[] ansIds = new int[( clen + nlen )];
						string[] ansFields = new string[( clen + nlen )];
						int ci = 0;
						int ni = 0;
						int ansi = 0;
						while (true) {
							if ( ! ((( (( ci < clen )) ? (( ni < nlen )) : (false) ))) ) {
								break;
							}
							
							if (( cids[ci] < nids[ni] )) {
								ansIds[ansi] = cids[ci];
								ansFields[ansi] = ((string) (cfields[ci]) );
								ci = ( ci + 1 );
							}
							else {
								ansIds[ansi] = nids[ni];
								ansFields[ansi] = ((string) (nfields[ni]) );
								ni = ( ni + 1 );
							}
							
							ansi = ( ansi + 1 );
						}
						
						if (( ci < clen )) {
							global::System.Array.Copy(((global::System.Array) (cids) ), ((int) (ci) ), ((global::System.Array) (ansIds) ), ((int) (ansi) ), ((int) (( clen - ci )) ));
							global::System.Array.Copy(((global::System.Array) (cfields) ), ((int) (ci) ), ((global::System.Array) (ansFields) ), ((int) (ansi) ), ((int) (( clen - ci )) ));
							ansi = ( ansi + (( clen - ci )) );
						}
						
						if (( ni < nlen )) {
							global::System.Array.Copy(((global::System.Array) (nids) ), ((int) (ni) ), ((global::System.Array) (ansIds) ), ((int) (ansi) ), ((int) (( nlen - ni )) ));
							global::System.Array.Copy(((global::System.Array) (nfields) ), ((int) (ni) ), ((global::System.Array) (ansFields) ), ((int) (ansi) ), ((int) (( nlen - ni )) ));
							ansi = ( ansi + (( nlen - ni )) );
						}
						
						global::Loreline.Internal.Lang.FieldLookup.fieldIds = ansIds;
						global::Loreline.Internal.Lang.FieldLookup.fields = ansFields;
						global::Loreline.Internal.Lang.FieldLookup.length = ansi;
					}
					;
				}
				
			}
		}
		
		
		public static int doHash(string s) {
			unchecked {
				int acc = 0;
				{
					int _g = 0;
					int _g1 = s.Length;
					while (( _g < _g1 )) {
						int i = _g++;
						acc = ( ( ( 223 * (( acc >> 1 )) ) + ((int) (s[i]) ) ) << 1 );
					}
					
				}
				
				return ((int) (( ((uint) (acc) ) >> 1 )) );
			}
		}
		
		
		public static string lookupHash(int key) {
			unchecked {
				int[] ids = global::Loreline.Internal.Lang.FieldLookup.fieldIds;
				int min = 0;
				int max = global::Loreline.Internal.Lang.FieldLookup.length;
				while (( min < max )) {
					int mid = ( min + ( (( max - min )) / 2 ) );
					int imid = ids[mid];
					if (( key < imid )) {
						max = mid;
					}
					else if (( key > imid )) {
						min = ( mid + 1 );
					}
					else {
						return ((string) (global::Loreline.Internal.Lang.FieldLookup.fields[mid]) );
					}
					
				}
				
				throw ((global::System.Exception) (global::Loreline.Internal.Exception.thrown(global::Loreline.Internal.Lang.Runtime.concat("Field not found for hash ", global::Loreline.Internal.Lang.Runtime.toString(key)))) );
			}
		}
		
		
		public static int hash(string s) {
			unchecked {
				if (( s == null )) {
					return 0;
				}
				
				int acc = 0;
				{
					int _g = 0;
					int _g1 = s.Length;
					while (( _g < _g1 )) {
						int i = _g++;
						acc = ( ( ( 223 * (( acc >> 1 )) ) + ((int) (s[i]) ) ) << 1 );
					}
					
				}
				
				int key = ((int) (( ((uint) (acc) ) >> 1 )) );
				int[] ids = global::Loreline.Internal.Lang.FieldLookup.fieldIds;
				string[] fld = global::Loreline.Internal.Lang.FieldLookup.fields;
				int min = 0;
				int max = global::Loreline.Internal.Lang.FieldLookup.length;
				int len = global::Loreline.Internal.Lang.FieldLookup.length;
				while (( min < max )) {
					int mid = ((int) (( min + ( ((double) ((( max - min ))) ) / 2 ) )) );
					int imid = ids[mid];
					if (( key < imid )) {
						max = mid;
					}
					else if (( key > imid )) {
						min = ( mid + 1 );
					}
					else {
						string field = ((string) (fld[mid]) );
						if (( field != s )) {
							return  ~ (key) ;
						}
						
						return key;
					}
					
				}
				
				lock(typeof(global::Loreline.Internal.Lang.FieldLookup)){
					if (( len != global::Loreline.Internal.Lang.FieldLookup.length )) {
						return global::Loreline.Internal.Lang.FieldLookup.hash(s);
					}
					
					global::Loreline.Internal.Lang.FieldLookup.fieldIds = global::Loreline.Internal.Lang.FieldLookup.insertInt(global::Loreline.Internal.Lang.FieldLookup.fieldIds, global::Loreline.Internal.Lang.FieldLookup.length, min, key);
					global::Loreline.Internal.Lang.FieldLookup.fields = global::Loreline.Internal.Lang.FieldLookup.insertString(global::Loreline.Internal.Lang.FieldLookup.fields, global::Loreline.Internal.Lang.FieldLookup.length, min, s);
					 ++ global::Loreline.Internal.Lang.FieldLookup.length;
				}
				;
				return key;
			}
		}
		
		
		public static int findHash(int hash, int[] hashs, int length) {
			unchecked {
				int min = 0;
				int max = length;
				while (( min < max )) {
					int mid = ( (( max + min )) / 2 );
					int imid = hashs[mid];
					if (( hash < imid )) {
						max = mid;
					}
					else if (( hash > imid )) {
						min = ( mid + 1 );
					}
					else {
						return mid;
					}
					
				}
				
				return  ~ (min) ;
			}
		}
		
		
		public static void removeInt(int[] a, int length, int pos) {
			unchecked {
				global::System.Array.Copy(((global::System.Array) (a) ), ((int) (( pos + 1 )) ), ((global::System.Array) (a) ), ((int) (pos) ), ((int) (( ( length - pos ) - 1 )) ));
				a[( length - 1 )] = 0;
			}
		}
		
		
		public static void removeFloat(double[] a, int length, int pos) {
			unchecked {
				global::System.Array.Copy(((global::System.Array) (a) ), ((int) (( pos + 1 )) ), ((global::System.Array) (a) ), ((int) (pos) ), ((int) (( ( length - pos ) - 1 )) ));
				a[( length - 1 )] = ((double) (0) );
			}
		}
		
		
		public static void removeDynamic(object[] a, int length, int pos) {
			unchecked {
				global::System.Array.Copy(((global::System.Array) (a) ), ((int) (( pos + 1 )) ), ((global::System.Array) (a) ), ((int) (pos) ), ((int) (( ( length - pos ) - 1 )) ));
				a[( length - 1 )] = null;
			}
		}
		
		
		public static int[] insertInt(int[] a, int length, int pos, int x) {
			unchecked {
				int[] a1 = a;
				int capacity = ( a1 as global::System.Array ).Length;
				if (( pos == length )) {
					if (( capacity == length )) {
						int[] newarr = new int[( (( length << 1 )) + 1 )];
						( a1 as global::System.Array ).CopyTo(((global::System.Array) (newarr) ), ((int) (0) ));
						a1 = newarr;
					}
					
				}
				else if (( pos == 0 )) {
					if (( capacity == length )) {
						int[] newarr1 = new int[( (( length << 1 )) + 1 )];
						global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (newarr1) ), ((int) (1) ), ((int) (length) ));
						a1 = newarr1;
					}
					else {
						global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (a1) ), ((int) (1) ), ((int) (length) ));
					}
					
				}
				else if (( capacity == length )) {
					int[] newarr2 = new int[( (( length << 1 )) + 1 )];
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (newarr2) ), ((int) (0) ), ((int) (pos) ));
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (pos) ), ((global::System.Array) (newarr2) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					a1 = newarr2;
				}
				else {
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (pos) ), ((global::System.Array) (a1) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (a1) ), ((int) (0) ), ((int) (pos) ));
				}
				
				a1[pos] = x;
				return a1;
			}
		}
		
		
		public static double[] insertFloat(double[] a, int length, int pos, double x) {
			unchecked {
				double[] a1 = a;
				int capacity = ( a1 as global::System.Array ).Length;
				if (( pos == length )) {
					if (( capacity == length )) {
						double[] newarr = new double[( (( length << 1 )) + 1 )];
						( a1 as global::System.Array ).CopyTo(((global::System.Array) (newarr) ), ((int) (0) ));
						a1 = newarr;
					}
					
				}
				else if (( pos == 0 )) {
					if (( capacity == length )) {
						double[] newarr1 = new double[( (( length << 1 )) + 1 )];
						global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (newarr1) ), ((int) (1) ), ((int) (length) ));
						a1 = newarr1;
					}
					else {
						global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (a1) ), ((int) (1) ), ((int) (length) ));
					}
					
				}
				else if (( capacity == length )) {
					double[] newarr2 = new double[( (( length << 1 )) + 1 )];
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (newarr2) ), ((int) (0) ), ((int) (pos) ));
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (pos) ), ((global::System.Array) (newarr2) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					a1 = newarr2;
				}
				else {
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (pos) ), ((global::System.Array) (a1) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (a1) ), ((int) (0) ), ((int) (pos) ));
				}
				
				a1[pos] = x;
				return a1;
			}
		}
		
		
		public static object[] insertDynamic(object[] a, int length, int pos, object x) {
			unchecked {
				object[] a1 = a;
				int capacity = ( a1 as global::System.Array ).Length;
				if (( pos == length )) {
					if (( capacity == length )) {
						object[] newarr = new object[( (( length << 1 )) + 1 )];
						( a1 as global::System.Array ).CopyTo(((global::System.Array) (newarr) ), ((int) (0) ));
						a1 = newarr;
					}
					
				}
				else if (( pos == 0 )) {
					if (( capacity == length )) {
						object[] newarr1 = new object[( (( length << 1 )) + 1 )];
						global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (newarr1) ), ((int) (1) ), ((int) (length) ));
						a1 = newarr1;
					}
					else {
						global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (a1) ), ((int) (1) ), ((int) (length) ));
					}
					
				}
				else if (( capacity == length )) {
					object[] newarr2 = new object[( (( length << 1 )) + 1 )];
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (newarr2) ), ((int) (0) ), ((int) (pos) ));
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (pos) ), ((global::System.Array) (newarr2) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					a1 = newarr2;
				}
				else {
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (pos) ), ((global::System.Array) (a1) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (a1) ), ((int) (0) ), ((int) (pos) ));
				}
				
				a1[pos] = ((object) (x) );
				return a1;
			}
		}
		
		
		public static string[] insertString(string[] a, int length, int pos, string x) {
			unchecked {
				string[] a1 = a;
				int capacity = ( a1 as global::System.Array ).Length;
				if (( pos == length )) {
					if (( capacity == length )) {
						string[] newarr = new string[( (( length << 1 )) + 1 )];
						( a1 as global::System.Array ).CopyTo(((global::System.Array) (newarr) ), ((int) (0) ));
						a1 = newarr;
					}
					
				}
				else if (( pos == 0 )) {
					if (( capacity == length )) {
						string[] newarr1 = new string[( (( length << 1 )) + 1 )];
						global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (newarr1) ), ((int) (1) ), ((int) (length) ));
						a1 = newarr1;
					}
					else {
						global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (a1) ), ((int) (1) ), ((int) (length) ));
					}
					
				}
				else if (( capacity == length )) {
					string[] newarr2 = new string[( (( length << 1 )) + 1 )];
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (newarr2) ), ((int) (0) ), ((int) (pos) ));
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (pos) ), ((global::System.Array) (newarr2) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					a1 = newarr2;
				}
				else {
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (pos) ), ((global::System.Array) (a1) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (a1) ), ((int) (0) ), ((int) (pos) ));
				}
				
				a1[pos] = x;
				return a1;
			}
		}
		
		
		public static global::Loreline.Internal.Lang.FieldHashConflict getHashConflict(global::Loreline.Internal.Lang.FieldHashConflict head, int hash, string name) {
			while (( head != null )) {
				if (( ( head.hash == hash ) && ( head.name == name ) )) {
					return head;
				}
				
				head = head.next;
			}
			
			return null;
		}
		
		
		public static void setHashConflict(ref global::Loreline.Internal.Lang.FieldHashConflict head, int hash, string name, object @value) {
			global::Loreline.Internal.Lang.FieldHashConflict node = head;
			while (( node != null )) {
				if (( ( node.hash == hash ) && ( node.name == name ) )) {
					node.@value = @value;
					return;
				}
				
				node = ((global::Loreline.Internal.Lang.FieldHashConflict) (node.next) );
			}
			
			head = ((global::Loreline.Internal.Lang.FieldHashConflict) (new global::Loreline.Internal.Lang.FieldHashConflict(hash, name, @value, ((global::Loreline.Internal.Lang.FieldHashConflict) (head) ))) );
		}
		
		
		public static bool deleteHashConflict(ref global::Loreline.Internal.Lang.FieldHashConflict head, int hash, string name) {
			if (( head == null )) {
				return false;
			}
			
			if (( ( head.hash == hash ) && ( head.name == name ) )) {
				head = ((global::Loreline.Internal.Lang.FieldHashConflict) (head.next) );
				return true;
			}
			
			global::Loreline.Internal.Lang.FieldHashConflict prev = head;
			global::Loreline.Internal.Lang.FieldHashConflict node = head.next;
			while (( node != null )) {
				if (( ( node.hash == hash ) && ( node.name == name ) )) {
					prev.next = node.next;
					return true;
				}
				
				node = node.next;
			}
			
			return false;
		}
		
		
		public static void addHashConflictNames(global::Loreline.Internal.Lang.FieldHashConflict head, global::Loreline.Internal.Root.Array<string> arr) {
			while (( head != null )) {
				arr.push(head.name);
				head = head.next;
			}
			
		}
		
		
	}
}



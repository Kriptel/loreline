// Generated by Haxe 4.3.6
using global::Loreline.Internal.Root;

#pragma warning disable 109, 114, 219, 429, 168, 162, IL2026, IL2070, IL2072, IL2060, CS0108
namespace Loreline.Runtime {
	public class Objects : global::Loreline.Internal.Lang.HxObject {
		
		public Objects(global::Loreline.Internal.Lang.EmptyObject empty) {
		}
		
		
		public Objects() {
			global::Loreline.Runtime.Objects.__hx_ctor_loreline_Objects(this);
		}
		
		
		protected static void __hx_ctor_loreline_Objects(global::Loreline.Runtime.Objects __hx_this) {
		}
		
		
		public static bool isFields(object @value) {
			if (( @value is global::Loreline.Runtime.Fields )) {
				return true;
			}
			else if (( @value is global::Loreline.Internal.Ds.StringMap )) {
				return true;
			}
			else if (( @value is global::Loreline.Internal.Ds.IntMap )) {
				return false;
			}
			else if (global::Loreline.Runtime.Objects.isCsDict(@value)) {
				return true;
			}
			else if (( ( ( (( ( ( @value is int ) || ( @value is uint ) ) || global::Loreline.Internal.Lang.Runtime.isInt(@value) )) || (( ( @value is double ) || ( ( @value is int ) || ( @value is uint ) ) )) ) || ( @value is bool ) ) || ( @value is string ) )) {
				return false;
			}
			else if (global::Loreline.Runtime.Arrays.isArray(@value)) {
				return false;
			}
			
			return true;
		}
		
		
		public static object getField(global::Loreline.Runtime.Interpreter interpreter, object fields, string name) {
			if (( fields is global::Loreline.Runtime.Fields )) {
				return ((global::Loreline.Runtime.Fields) (fields) ).lorelineGet(interpreter, name);
			}
			else if (( fields is global::Loreline.Internal.Ds.StringMap )) {
				return (((global::Loreline.Internal.Ds.StringMap<object>) (global::Loreline.Internal.Ds.StringMap<object>.__hx_cast<object>(((global::Loreline.Internal.Ds.StringMap) (fields) ))) ).@get(name)).toDynamic();
			}
			else if (global::Loreline.Runtime.Objects.isCsDict(fields)) {
				return global::Loreline.Runtime.Objects.getCsDictField(fields, name);
			}
			else {
				return global::Loreline.Internal.Root.Reflect.getProperty(fields, name);
			}
			
		}
		
		
		public static global::Loreline.Internal.Root.Array<string> getFields(global::Loreline.Runtime.Interpreter interpreter, object fields) {
			if (( fields is global::Loreline.Runtime.Fields )) {
				return ((global::Loreline.Runtime.Fields) (fields) ).lorelineFields(interpreter);
			}
			else if (( fields is global::Loreline.Internal.Ds.StringMap )) {
				global::Loreline.Internal.Root.Array<string> _g = new global::Loreline.Internal.Root.Array<string>(new string[]{});
				{
					object key = ((object) (new global::Loreline.Internal.Ds._StringMap.StringMapKeyIterator<object>(((global::Loreline.Internal.Ds.StringMap<object>) (global::Loreline.Internal.Ds.StringMap<object>.__hx_cast<object>(((global::Loreline.Internal.Ds.StringMap) (fields) ))) ))) );
					while (global::Loreline.Internal.Lang.Runtime.toBool(global::Loreline.Internal.Lang.Runtime.callField(key, "hasNext", 407283053, null))) {
						string key1 = global::Loreline.Internal.Lang.Runtime.toString(global::Loreline.Internal.Lang.Runtime.callField(key, "next", 1224901875, null));
						_g.push(key1);
					}
					
				}
				
				return _g;
			}
			else if (global::Loreline.Runtime.Objects.isCsDict(fields)) {
				return global::Loreline.Runtime.Objects.getCsDictKeys(fields);
			}
			else {
				return global::Loreline.Internal.Root.Reflect.fields(fields);
			}
			
		}
		
		
		public static void setField(global::Loreline.Runtime.Interpreter interpreter, object fields, string name, object @value) {
			if (( fields is global::Loreline.Runtime.Fields )) {
				((global::Loreline.Runtime.Fields) (fields) ).lorelineSet(interpreter, name, @value);
			}
			else if (( fields is global::Loreline.Internal.Ds.StringMap )) {
				((global::Loreline.Internal.Ds.StringMap<object>) (global::Loreline.Internal.Ds.StringMap<object>.__hx_cast<object>(((global::Loreline.Internal.Ds.StringMap) (fields) ))) ).@set(name, @value);
			}
			else if (global::Loreline.Runtime.Objects.isCsDict(fields)) {
				global::Loreline.Runtime.Objects.setCsDictField(fields, name, @value);
			}
			else {
				global::Loreline.Internal.Root.Reflect.setProperty(fields, name, @value);
			}
			
		}
		
		
		public static bool fieldExists(global::Loreline.Runtime.Interpreter interpreter, object fields, string name) {
			if (( fields is global::Loreline.Runtime.Fields )) {
				return ((global::Loreline.Runtime.Fields) (fields) ).lorelineExists(interpreter, name);
			}
			else if (( fields is global::Loreline.Internal.Ds.StringMap )) {
				return ((global::Loreline.Internal.Ds.StringMap<object>) (global::Loreline.Internal.Ds.StringMap<object>.__hx_cast<object>(((global::Loreline.Internal.Ds.StringMap) (fields) ))) ).exists(name);
			}
			else if (global::Loreline.Runtime.Objects.isCsDict(fields)) {
				return global::Loreline.Runtime.Objects.csDictFieldExists(fields, name);
			}
			else {
				return global::Loreline.Internal.Root.Reflect.hasField(fields, name);
			}
			
		}
		
		
		public static object createFields(global::Loreline.Runtime.Interpreter interpreter, string type) {
			if (( type != null )) {
				object instance = global::Loreline.Internal.Root.Type.createEmptyInstance<object>(((global::System.Type) (global::Loreline.Internal.Root.Type.resolveClass(type)) ));
				if (( instance is global::Loreline.Runtime.Fields )) {
					global::Loreline.Runtime.Fields fields = ((global::Loreline.Runtime.Fields) (instance) );
					fields.lorelineCreate(interpreter);
				}
				
				return instance;
			}
			
			return new System.Collections.Generic.Dictionary<string,object>();
		}
		
		
		public static bool isCsDict(object fields) {
			return fields is global::System.Collections.IDictionary;
		}
		
		
		public static object getCsDictField(object fields, string name) {
			global::System.Collections.IDictionary dict = (global::System.Collections.IDictionary)fields;
			return dict[name];
		}
		
		
		public static void setCsDictField(object fields, string name, object @value) {
			global::System.Collections.IDictionary dict = (global::System.Collections.IDictionary)fields;
			dict[name] = @value;
		}
		
		
		public static bool csDictFieldExists(object fields, string name) {
			global::System.Collections.IDictionary dict = (global::System.Collections.IDictionary)fields;
			return dict.Contains(name);
		}
		
		
		public static global::Loreline.Internal.Root.Array<string> getCsDictKeys(object fields) {
			global::System.Collections.IDictionary dict = (global::System.Collections.IDictionary)fields;
			global::Loreline.Internal.Root.Array<string> keys = new global::Loreline.Internal.Root.Array<string>(new string[]{});
			foreach (var dictKey in dict.Keys) {;
			if (dictKey is string) {;
			string key = null;
			key = (string)dictKey;
			keys.push(key);
			};
			};
			return keys;
		}
		
		
	}
}


